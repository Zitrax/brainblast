<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Kyra: KrImage Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>KrImage Class Reference</h1><!-- doxytag: class="KrImage" --><!-- doxytag: inherits="KrImNode" -->The parent class for any Node that actually draws to the screen.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="image_8h-source.html">image.h</a>&gt;</code>
<p>
<p>Inheritance diagram for KrImage:
<p><center><img src="classKrImage.png" usemap="#KrImage_map" border="0" alt=""></center>
<map name="KrImage_map">
<area href="classKrImNode.html" alt="KrImNode" shape="rect" coords="117,0,185,24">
<area href="classKrBox.html" alt="KrBox" shape="rect" coords="0,112,68,136">
<area href="classKrCanvas.html" alt="KrCanvas" shape="rect" coords="78,112,146,136">
<area href="classKrSprite.html" alt="KrSprite" shape="rect" coords="156,112,224,136">
<area href="classKrTile.html" alt="KrTile" shape="rect" coords="234,112,302,136">
</map>
<a href="classKrImage-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKrImage.html#39d3eddcd81482dcc6bcbf45ca8296d8">QueryBoundingBox</a> (grinliz::Rectangle2I *boundingBox, int window)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the bounding box of the image, in its current state.  <a href="#39d3eddcd81482dcc6bcbf45ca8296d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKrImage.html#af551c933bc03d4ea1708df9a0699679">CheckCollision</a> (<a class="el" href="classKrImage.html">KrImage</a> *other, int window=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check to see if this object collides with another object.  <a href="#af551c933bc03d4ea1708df9a0699679"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="657a587eb258dd169e2fbff3a07f4dfb"></a><!-- doxytag: member="KrImage::ToImage" ref="657a587eb258dd169e2fbff3a07f4dfb" args="()" -->
virtual <a class="el" href="classKrImage.html">KrImage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKrImage.html#657a587eb258dd169e2fbff3a07f4dfb">ToImage</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer if this is an image. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The parent class for any Node that actually draws to the screen. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classKrImNode.html">KrImNode</a> </dd></dl>

<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="af551c933bc03d4ea1708df9a0699679"></a><!-- doxytag: member="KrImage::CheckCollision" ref="af551c933bc03d4ea1708df9a0699679" args="(KrImage *other, int window=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool KrImage::CheckCollision           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKrImage.html">KrImage</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>window</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check to see if this object collides with another object. 
<p>
Only Sprites and Canvases can collide. (Boxes, Tiles, etc. are ignored.)<p>
Composite Objects -- TextBox and Widgets -- are built on Sprites. Their components *will* collide. Something to be aware of.<p>
This is a pixel perfect (or near perfect, if scaled) 2D collision detection. 2D collision detection is a necessary -- but not sufficient -- collision criteria for 3D collision, if you are using an isometric view. For top down or side views, this is a complete detection scheme.<p>
See <a class="el" href="classKrImageTree.html#783cd9a308fa15b7e067e3bda5281d09">KrImageTree::CheckChildCollision</a> and <a class="el" href="classKrImageTree.html#706466ccfc9663780abe65f2509571ae">KrImageTree::CheckAllCollision</a> for possibily more useful Tree variants of this call.<p>
The ImageTree must be in an consistent state in order to for collision checking to work. The function <a class="el" href="classKrImNode.html#e3d711d058ec189ce24609cb97fbf419">Engine()</a>-&gt;Tree()-&gt;Walk() will bring the tree into a consistent state. The following operations will invalidate the state of the Tree, causing collision checking to fail:<p>
<ul>
<li>Setting any X, Y, or Scale property</li><li>Adding anything to the Tree. (Deleting from the tree is safe, however.)</li></ul>
<p>
Walk can be a somewhat expensive call. And you should avoid calling it more than once per frame. A normal sequence of events would be something like:<p>
<ul>
<li>Move sprites, canvases, etc. Game &amp; logic actions.</li><li>Call Walk</li><li>Check collisions. Call deletes as you go, queue up additional move and scaling actions.</li><li>Apply queued move / scaling actions.</li><li>Draw()</li></ul>
<p>
Note that if you aren't using collision detection, you should never need to call Walk() directly. Also, if you check collisions *after* Draw(), but before any x/y/scale transformations, you don't need to call Walk().<p>
Returns true if the objects collide.<p>
A window can be specified. Depending on the transformations appiled, collisions can be different per window.<p>
Collisions with scaled sprites and canvases is supported with one caveat: un-cached sprites can not be collision detected. For a full discussion of scaling, see the HTML docs. In brief, a scaled image can be cached (pre-calculated at a give x and y scale) or real time scaled. Real time scaled sprites can not be used in a collision test. 
</div>
</div><p>
<a class="anchor" name="39d3eddcd81482dcc6bcbf45ca8296d8"></a><!-- doxytag: member="KrImage::QueryBoundingBox" ref="39d3eddcd81482dcc6bcbf45ca8296d8" args="(grinliz::Rectangle2I *boundingBox, int window)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void KrImage::QueryBoundingBox           </td>
          <td>(</td>
          <td class="paramtype">grinliz::Rectangle2I *&nbsp;</td>
          <td class="paramname"> <em>boundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>window</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the bounding box of the image, in its current state. 
<p>
If this is a sprite, it will be the bounding box of the current frame and action. The bounds are relative to the hotspot, so xmin and ymin will often be not zero.<p>
The current transformation matrix will be applied, so the result may be transformed bounds. 
<p>
Implemented in <a class="el" href="classKrBox.html#8b83a9c1997604b3954480d75de41516">KrBox</a>, <a class="el" href="classKrCanvas.html#3fd5b6bd240afa6aa67239b394334970">KrCanvas</a>, <a class="el" href="classKrSprite.html#1209c24bfd7de66b535bf4fcda81131e">KrSprite</a>, and <a class="el" href="classKrTile.html#23b350e1a12700d3aa30becc0e99ca12">KrTile</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="image_8h-source.html">image.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jul 20 20:45:32 2006 for Kyra by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
